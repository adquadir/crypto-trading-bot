"""
üéØ Real Signal Tracker

Logs every signal generated by the system for true performance tracking.
This enables Phase 2: Real Signal Replay Backtesting.
"""

import asyncio
import asyncpg
import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
import json
import hashlib

logger = logging.getLogger(__name__)

@dataclass
class SignalRecord:
    """Individual signal record for tracking"""
    signal_id: str
    symbol: str
    strategy: str
    direction: str
    signal_type: Optional[str]
    entry_price: float
    stop_loss: float
    take_profit: float
    confidence: float
    risk_reward_ratio: float
    market_regime: Optional[str]
    funding_rate: Optional[float]
    open_interest: Optional[int]
    volume_24h: Optional[float]
    trading_mode: str
    timestamp: datetime

class RealSignalTracker:
    """
    üéØ Tracks all real signals generated by the system
    
    This is the foundation for true signal replay backtesting.
    """
    
    def __init__(self, db_url: str = None):
        # Get database URL from environment or use default
        self.db_url = db_url or os.getenv('DATABASE_URL', 'postgresql://crypto_user:crypto_password@localhost:5432/crypto_trading')
        self.connection_pool = None
        self.enabled = os.getenv('ENABLE_SIGNAL_TRACKING', 'true').lower() == 'true'
        
    async def initialize(self):
        """Initialize database connection"""
        if not self.enabled:
            logger.info("‚ö†Ô∏è Signal tracking disabled in configuration")
            return
            
        try:
            self.connection_pool = await asyncpg.create_pool(
                self.db_url,
                min_size=1,
                max_size=5,
                command_timeout=30
            )
            
            # Run migration if needed
            await self._ensure_tables_exist()
            logger.info("‚úÖ Real Signal Tracker initialized")
            
        except Exception as e:
            logger.error(f"‚ùå Failed to initialize Signal Tracker: {e}")
            logger.error("üí° Make sure PostgreSQL is running and database exists")
            logger.error(f"üí° Database URL: {self.db_url}")
            self.enabled = False
    
    async def _ensure_tables_exist(self):
        """Ensure signal tracking tables exist"""
        try:
            async with self.connection_pool.acquire() as conn:
                # Read and execute migration
                migration_path = 'src/database/migrations/create_signal_tracking.sql'
                if os.path.exists(migration_path):
                    with open(migration_path, 'r') as f:
                        migration_sql = f.read()
                    
                    await conn.execute(migration_sql)
                    logger.info("‚úÖ Signal tracking tables ready")
                else:
                    # Create tables inline if migration file doesn't exist
                    await self._create_tables_inline(conn)
                
        except Exception as e:
            logger.error(f"‚ùå Failed to create signal tracking tables: {e}")
            raise
    
    async def _create_tables_inline(self, conn):
        """Create tables inline if migration file is missing"""
        await conn.execute("""
            CREATE TABLE IF NOT EXISTS historical_signals (
                id SERIAL PRIMARY KEY,
                signal_id VARCHAR(100) UNIQUE NOT NULL,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                
                -- Signal Details
                symbol VARCHAR(20) NOT NULL,
                strategy VARCHAR(50) NOT NULL,
                direction VARCHAR(10) NOT NULL,
                signal_type VARCHAR(50),
                
                -- Price Levels
                entry_price DECIMAL(20,8) NOT NULL,
                stop_loss DECIMAL(20,8) NOT NULL,
                take_profit DECIMAL(20,8) NOT NULL,
                
                -- Signal Quality
                confidence DECIMAL(5,4) NOT NULL,
                risk_reward_ratio DECIMAL(10,4),
                
                -- Market Context
                market_regime VARCHAR(20),
                funding_rate DECIMAL(10,8),
                open_interest BIGINT,
                volume_24h DECIMAL(20,8),
                
                -- Signal Source
                trading_mode VARCHAR(20),
                source_system VARCHAR(50) DEFAULT 'opportunity_manager',
                
                -- Outcome Tracking
                status VARCHAR(20) DEFAULT 'active',
                actual_exit_price DECIMAL(20,8),
                actual_exit_time TIMESTAMP,
                actual_pnl DECIMAL(20,8),
                actual_return_pct DECIMAL(10,6),
                trade_duration_minutes INTEGER,
                
                -- Metadata
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );
            
            -- Indexes for performance
            CREATE INDEX IF NOT EXISTS idx_historical_signals_symbol ON historical_signals(symbol);
            CREATE INDEX IF NOT EXISTS idx_historical_signals_strategy ON historical_signals(strategy);
            CREATE INDEX IF NOT EXISTS idx_historical_signals_timestamp ON historical_signals(timestamp);
            CREATE INDEX IF NOT EXISTS idx_historical_signals_status ON historical_signals(status);
        """)
        logger.info("‚úÖ Created signal tracking tables inline")
    
    async def log_signal(
        self,
        signal: Dict[str, Any],
        trading_mode: str = "live",
        market_context: Dict[str, Any] = None
    ) -> str:
        """
        Log a signal to the database for tracking
        
        Args:
            signal: The signal data from your signal generator
            trading_mode: 'live', 'paper', or 'backtest'
            market_context: Additional market data (funding rate, etc.)
            
        Returns:
            signal_id: Unique identifier for this signal
        """
        if not self.enabled or not self.connection_pool:
            return None
            
        try:
            # Generate unique signal ID
            signal_id = self._generate_signal_id(signal, trading_mode)
            
            # Extract market context
            market_context = market_context or {}
            
            # Calculate risk/reward ratio
            entry = float(signal.get('entry', signal.get('entry_price', 0)))
            tp = float(signal.get('take_profit', 0))
            sl = float(signal.get('stop_loss', 0))
            
            risk = abs(entry - sl) if sl != 0 else 0
            reward = abs(tp - entry) if tp != 0 else 0
            risk_reward = reward / risk if risk > 0 else 0
            
            # Prepare signal record with proper type conversions
            record = SignalRecord(
                signal_id=signal_id,
                symbol=str(signal.get('symbol', '')),
                strategy=str(signal.get('strategy', 'unknown')),
                direction=str(signal.get('direction', '')),
                signal_type=signal.get('signal_type'),
                entry_price=entry,
                stop_loss=sl,
                take_profit=tp,
                confidence=float(signal.get('confidence', 0)),
                risk_reward_ratio=risk_reward,
                market_regime=market_context.get('market_regime'),
                funding_rate=float(market_context.get('funding_rate')) if market_context.get('funding_rate') is not None else None,
                open_interest=int(float(market_context.get('open_interest'))) if market_context.get('open_interest') is not None else None,
                volume_24h=float(market_context.get('volume_24h')) if market_context.get('volume_24h') is not None else None,
                trading_mode=trading_mode,
                timestamp=datetime.now()
            )
            
            # Insert into database
            await self._insert_signal_record(record)
            
            logger.info(f"üìä Logged signal: {record.symbol} {record.strategy} {record.direction} (ID: {signal_id[:8]}...)")
            return signal_id
            
        except Exception as e:
            logger.error(f"‚ùå Failed to log signal: {e}")
            return None
    
    async def _insert_signal_record(self, record: SignalRecord):
        """Insert signal record into database"""
        async with self.connection_pool.acquire() as conn:
            await conn.execute("""
                INSERT INTO historical_signals (
                    signal_id, symbol, strategy, direction, signal_type,
                    entry_price, stop_loss, take_profit, confidence, risk_reward_ratio,
                    market_regime, funding_rate, open_interest, volume_24h,
                    trading_mode, source_system, timestamp
                ) VALUES (
                    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
                    $11, $12, $13, $14, $15, $16, $17
                )
                ON CONFLICT (signal_id) DO NOTHING
            """,
                record.signal_id, record.symbol, record.strategy, record.direction, record.signal_type,
                record.entry_price, record.stop_loss, record.take_profit, record.confidence, record.risk_reward_ratio,
                record.market_regime, record.funding_rate, record.open_interest, record.volume_24h,
                record.trading_mode, "opportunity_manager", record.timestamp
            )
    
    async def update_signal_outcome(
        self,
        signal_id: str,
        status: str,  # 'hit_tp', 'hit_sl', 'manual_close', 'expired'
        exit_price: float,
        exit_time: datetime = None
    ):
        """
        Update signal outcome when trade closes
        
        Args:
            signal_id: The signal ID to update
            status: Final status of the signal
            exit_price: Actual exit price
            exit_time: When the trade closed
        """
        if not self.enabled or not self.connection_pool:
            return
            
        try:
            exit_time = exit_time or datetime.now()
            
            async with self.connection_pool.acquire() as conn:
                # Get original signal data
                signal_data = await conn.fetchrow("""
                    SELECT entry_price, stop_loss, take_profit, direction, timestamp
                    FROM historical_signals 
                    WHERE signal_id = $1
                """, signal_id)
                
                if not signal_data:
                    logger.warning(f"‚ö†Ô∏è Signal {signal_id} not found for outcome update")
                    return
                
                # Calculate actual P&L and return
                entry_price = float(signal_data['entry_price'])
                direction = signal_data['direction']
                
                if direction == 'LONG':
                    pnl_pct = (exit_price - entry_price) / entry_price
                else:  # SHORT
                    pnl_pct = (entry_price - exit_price) / entry_price
                
                # Calculate trade duration
                duration_minutes = int((exit_time - signal_data['timestamp']).total_seconds() / 60)
                
                # Update the record
                await conn.execute("""
                    UPDATE historical_signals 
                    SET status = $1,
                        actual_exit_price = $2,
                        actual_exit_time = $3,
                        actual_return_pct = $4,
                        trade_duration_minutes = $5,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE signal_id = $6
                """, status, exit_price, exit_time, pnl_pct, duration_minutes, signal_id)
                
                logger.info(f"üìä Updated signal outcome: {signal_id[:8]}... -> {status} ({pnl_pct:.2%})")
                
        except Exception as e:
            logger.error(f"‚ùå Failed to update signal outcome: {e}")
    
    async def get_signal_performance(
        self,
        symbol: str = None,
        strategy: str = None,
        days_back: int = 30,
        trading_mode: str = "live"
    ) -> Dict[str, Any]:
        """
        Get real signal performance statistics
        
        This is the TRUE performance of your system!
        """
        if not self.enabled or not self.connection_pool:
            return {}
            
        try:
            async with self.connection_pool.acquire() as conn:
                # Build WHERE clause
                where_conditions = ["trading_mode = $1", "timestamp >= $2"]
                params = [trading_mode, datetime.now() - timedelta(days=days_back)]
                param_count = 2
                
                if symbol:
                    param_count += 1
                    where_conditions.append(f"symbol = ${param_count}")
                    params.append(symbol)
                    
                if strategy:
                    param_count += 1
                    where_conditions.append(f"strategy = ${param_count}")
                    params.append(strategy)
                
                where_clause = " AND ".join(where_conditions)
                
                # Get performance metrics
                performance = await conn.fetchrow(f"""
                    SELECT 
                        COUNT(*) as total_signals,
                        COUNT(*) FILTER (WHERE status = 'active') as active_signals,
                        COUNT(*) FILTER (WHERE status IN ('hit_tp', 'hit_sl', 'manual_close', 'expired')) as completed_signals,
                        COUNT(*) FILTER (WHERE status = 'hit_tp') as winning_signals,
                        COUNT(*) FILTER (WHERE status IN ('hit_sl', 'manual_close')) as losing_signals,
                        CASE 
                            WHEN COUNT(*) FILTER (WHERE status IN ('hit_tp', 'hit_sl', 'manual_close')) > 0 
                            THEN COUNT(*) FILTER (WHERE status = 'hit_tp')::DECIMAL / COUNT(*) FILTER (WHERE status IN ('hit_tp', 'hit_sl', 'manual_close'))
                            ELSE 0 
                        END as win_rate,
                        COALESCE(AVG(actual_return_pct), 0) as avg_return_pct,
                        COALESCE(SUM(actual_return_pct), 0) as total_return_pct,
                        COALESCE(AVG(trade_duration_minutes), 0) as avg_duration_minutes,
                        COALESCE(AVG(confidence), 0) as avg_confidence,
                        COALESCE(AVG(risk_reward_ratio), 0) as avg_risk_reward,
                        COALESCE(MAX(actual_return_pct), 0) as best_trade_pct,
                        COALESCE(MIN(actual_return_pct), 0) as worst_trade_pct
                    FROM historical_signals 
                    WHERE {where_clause}
                """, *params)
                
                return {
                    'total_signals': int(performance['total_signals']),
                    'active_signals': int(performance['active_signals']),
                    'completed_signals': int(performance['completed_signals']),
                    'winning_signals': int(performance['winning_signals']),
                    'losing_signals': int(performance['losing_signals']),
                    'win_rate': float(performance['win_rate']),
                    'avg_return_pct': float(performance['avg_return_pct']),
                    'total_return_pct': float(performance['total_return_pct']),
                    'avg_duration_minutes': float(performance['avg_duration_minutes']),
                    'avg_confidence': float(performance['avg_confidence']),
                    'avg_risk_reward': float(performance['avg_risk_reward']),
                    'best_trade_pct': float(performance['best_trade_pct']),
                    'worst_trade_pct': float(performance['worst_trade_pct'])
                }
                
        except Exception as e:
            logger.error(f"‚ùå Failed to get signal performance: {e}")
            return {}
    
    async def get_recent_signals(
        self,
        limit: int = 50,
        symbol: str = None,
        strategy: str = None,
        trading_mode: str = "live"
    ) -> List[Dict[str, Any]]:
        """Get recent signals for analysis"""
        if not self.enabled or not self.connection_pool:
            return []
            
        try:
            async with self.connection_pool.acquire() as conn:
                # Build WHERE clause
                where_conditions = ["trading_mode = $1"]
                params = [trading_mode]
                param_count = 1
                
                if symbol:
                    param_count += 1
                    where_conditions.append(f"symbol = ${param_count}")
                    params.append(symbol)
                    
                if strategy:
                    param_count += 1
                    where_conditions.append(f"strategy = ${param_count}")
                    params.append(strategy)
                
                where_clause = " AND ".join(where_conditions)
                
                signals = await conn.fetch(f"""
                    SELECT 
                        signal_id, symbol, strategy, direction, signal_type,
                        entry_price, stop_loss, take_profit, confidence,
                        status, actual_exit_price, actual_return_pct,
                        trade_duration_minutes, timestamp
                    FROM historical_signals 
                    WHERE {where_clause}
                    ORDER BY timestamp DESC 
                    LIMIT {limit}
                """, *params)
                
                return [dict(signal) for signal in signals]
                
        except Exception as e:
            logger.error(f"‚ùå Failed to get recent signals: {e}")
            return []
    
    def _generate_signal_id(self, signal: Dict, trading_mode: str) -> str:
        """Generate unique signal ID"""
        # Create deterministic ID based on signal content
        content = f"{signal.get('symbol')}_{signal.get('strategy')}_{signal.get('direction')}_{signal.get('entry_price')}_{trading_mode}_{datetime.now().isoformat()}"
        return hashlib.md5(content.encode()).hexdigest()
    
    async def close(self):
        """Close database connections"""
        if self.connection_pool:
            await self.connection_pool.close()

# Global instance
real_signal_tracker = RealSignalTracker()
