"""
üéØ Signal Tracking & Replay API Routes

Provides endpoints for:
- Real signal performance tracking
- Signal replay backtesting  
- Historical signal analysis
"""

from fastapi import APIRouter, HTTPException, BackgroundTasks
from typing import Dict, List, Optional, Any
import logging
from datetime import datetime, timedelta

from src.signals.signal_tracker import real_signal_tracker
from src.backtesting.signal_replay_backtester import signal_replay_backtester

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/signals", tags=["Signal Tracking & Replay"])

@router.get("/performance")
async def get_signal_performance(
    symbol: Optional[str] = None,
    strategy: Optional[str] = None,
    days_back: int = 30,
    trading_mode: str = "live"
):
    """
    Get REAL signal performance from your live system
    
    This shows the actual performance of signals generated by your system.
    """
    try:
        performance = await real_signal_tracker.get_signal_performance(
            symbol=symbol,
            strategy=strategy,
            days_back=days_back,
            trading_mode=trading_mode
        )
        
        if not performance:
            return {
                "success": False,
                "message": "No signal performance data found",
                "data": {}
            }
        
        return {
            "success": True,
            "message": f"Signal performance for last {days_back} days",
            "data": {
                "performance_metrics": performance,
                "period": f"{days_back} days",
                "symbol": symbol or "all symbols",
                "strategy": strategy or "all strategies",
                "trading_mode": trading_mode
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error getting signal performance: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get signal performance: {str(e)}")

@router.get("/recent")
async def get_recent_signals(
    limit: int = 50,
    symbol: Optional[str] = None,
    strategy: Optional[str] = None,
    trading_mode: str = "live"
):
    """Get recent signals from the tracking system"""
    try:
        signals = await real_signal_tracker.get_recent_signals(
            limit=limit,
            symbol=symbol,
            strategy=strategy,
            trading_mode=trading_mode
        )
        
        return {
            "success": True,
            "message": f"Retrieved {len(signals)} recent signals",
            "data": {
                "signals": signals,
                "total_count": len(signals),
                "filters": {
                    "symbol": symbol,
                    "strategy": strategy,
                    "trading_mode": trading_mode,
                    "limit": limit
                }
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error getting recent signals: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get recent signals: {str(e)}")

@router.post("/replay")
async def replay_signals(
    background_tasks: BackgroundTasks,
    symbol: Optional[str] = None,
    strategy: Optional[str] = None,
    days_back: int = 7,
    trading_mode: str = "live",
    max_signals: int = 100
):
    """
    üéØ REPLAY REAL SIGNALS - The True Backtesting
    
    This replays actual signals from your system with real market data
    to show what ACTUALLY happened.
    """
    try:
        # Initialize if needed
        if not signal_replay_backtester.connection_pool:
            await signal_replay_backtester.initialize()
        
        # Run signal replay
        replay_results = await signal_replay_backtester.replay_signals(
            symbol=symbol,
            strategy=strategy,
            days_back=days_back,
            trading_mode=trading_mode,
            max_signals=max_signals
        )
        
        if 'error' in replay_results:
            return {
                "success": False,
                "message": replay_results['error'],
                "data": {}
            }
        
        return {
            "success": True,
            "message": f"Replayed {replay_results.get('signals_replayed', 0)} real signals",
            "data": {
                "replay_results": replay_results,
                "parameters": {
                    "symbol": symbol,
                    "strategy": strategy,
                    "days_back": days_back,
                    "trading_mode": trading_mode,
                    "max_signals": max_signals
                },
                "analysis_type": "REAL_SIGNAL_REPLAY",
                "description": "This shows what actually happened to real signals from your system"
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error replaying signals: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to replay signals: {str(e)}")

@router.get("/outcomes/summary")
async def get_signal_outcomes_summary(
    symbol: Optional[str] = None,
    strategy: Optional[str] = None,
    days_back: int = 7
):
    """
    Get quick summary of recent signal outcomes
    
    Perfect for dashboard widgets!
    """
    try:
        summary = await signal_replay_backtester.get_signal_outcomes_summary(
            symbol=symbol,
            strategy=strategy,
            days_back=days_back
        )
        
        return {
            "success": True,
            "message": f"Signal outcomes summary for last {days_back} days",
            "data": {
                "summary": summary,
                "period": f"{days_back} days",
                "filters": {
                    "symbol": symbol,
                    "strategy": strategy
                }
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error getting signal outcomes summary: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get outcomes summary: {str(e)}")

@router.post("/validate/{signal_id}")
async def validate_single_signal(signal_id: str):
    """
    Validate a specific signal using both methods:
    1. Comparative backtesting (Phase 1)
    2. Real signal replay if available (Phase 3)
    """
    try:
        # Try to get the signal from tracking system first
        signals = await real_signal_tracker.get_recent_signals(limit=1000)
        target_signal = None
        
        for signal in signals:
            if signal['signal_id'] == signal_id:
                target_signal = signal
                break
        
        if target_signal:
            # Use real signal replay
            replay_results = await signal_replay_backtester.replay_signals(
                symbol=target_signal['symbol'],
                strategy=target_signal['strategy'],
                days_back=1,
                max_signals=1
            )
            
            return {
                "success": True,
                "message": "Signal validated using real replay data",
                "data": {
                    "validation_type": "REAL_SIGNAL_REPLAY",
                    "signal": target_signal,
                    "replay_results": replay_results,
                    "confidence_level": "HIGH - Based on actual signal performance"
                }
            }
        else:
            # Fallback to comparative backtesting
            from src.backtesting.backtest_engine import BacktestEngine
            
            # This would require extracting signal details and running comparative backtest
            return {
                "success": False,
                "message": "Signal not found in tracking system",
                "data": {
                    "validation_type": "NOT_AVAILABLE",
                    "suggestion": "Signal may be too old or not tracked"
                }
            }
        
    except Exception as e:
        logger.error(f"‚ùå Error validating signal {signal_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to validate signal: {str(e)}")

@router.get("/health")
async def signal_tracking_health():
    """Check health of signal tracking system"""
    try:
        # Check if tracker is initialized
        tracker_healthy = real_signal_tracker.enabled and real_signal_tracker.connection_pool is not None
        
        # Check if replay backtester is working
        replay_healthy = signal_replay_backtester.connection_pool is not None
        
        # Get recent activity
        recent_signals = await real_signal_tracker.get_recent_signals(limit=5)
        
        return {
            "success": True,
            "message": "Signal tracking system health check",
            "data": {
                "signal_tracker": {
                    "status": "healthy" if tracker_healthy else "unhealthy",
                    "enabled": real_signal_tracker.enabled,
                    "recent_signals_count": len(recent_signals)
                },
                "replay_backtester": {
                    "status": "healthy" if replay_healthy else "unhealthy",
                    "initialized": replay_healthy
                },
                "overall_status": "healthy" if (tracker_healthy and replay_healthy) else "degraded"
            }
        }
        
    except Exception as e:
        logger.error(f"‚ùå Error checking signal tracking health: {e}")
        return {
            "success": False,
            "message": f"Health check failed: {str(e)}",
            "data": {
                "overall_status": "unhealthy"
            }
        }
